'use strict';

const BPromise = require('bluebird');
const log = require('app/server/util/log.js');

/** @module publiser/publishtransform */

function maybeParseDate(value) {
  if (value) {
    var tmp = new Date();
    tmp.setTime(Date.parse(value));
    if (Number.isNaN(tmp)) {
      return value;
    }
    return tmp;
  }
  return value;
}

/**
 * Enum for ODK Aggregate form fields relevant to samples
 * @enum {string}
 */
const sampleFields = {
  SAMPLE_REPEAT: 'srepeat',
  SAMPLE_TRACKING_ID: 'stid',
  LAB_ID: 'labid',
  TYPE: 'stype'
};

/**
 * Parses the sample details from a form submission
 *
 * @param  {Object} data - The published form submission
 * @return {Sample}
 */
function parseSamples(data) {
  log.debug('Parse samples');

  var sampleData = data[sampleFields.SAMPLE_REPEAT];

  return BPromise.map(sampleData, function(sample) {
    return {
      stId: sample[sampleFields.SAMPLE_TRACKING_ID] || null,
      labId: sample[sampleFields.LAB_ID] || null,
      type: sample[sampleFields.TYPE] || null
    };
  });
}

/**
 * Enum for ODK Aggregate form fields relevant to updates
 * @enum {string}
 */
const submissionFields = {
  SUBMISSION_ID: 'instanceID',
  PERSON: 'person',
  FACILITY: 'facility',
  SIM_SERIAL: 'simserial',
  DEVICE_ID: 'deviceid',
  FORM_START_DATE: 'start',
  FORM_END_DATE: 'end',
  COMPLETED_DATE: '*meta-date-marked-as-complete*'
};

/**
 * Parses the submissin/form level fields from the published data.
 *
 * @param  {!string} formId - The form Id
 * @param  {Object} data - The published form submission
 * @return {Submission}
 */
function parseSubmission(formId, data) {
  log.debug('Parse submission');

  return {
    form: formId,
    submissionId: data[submissionFields.SUBMISSION_ID],
    facility: data[submissionFields.FACILITY] || null,
    person: data[submissionFields.PERSON] || null,
    deviceId: data[submissionFields.DEVICE_ID] || null,
    simSerial: data[submissionFields.SIM_SERIAL] || null,
    formStartDate: (maybeParseDate(
      data[submissionFields.FORM_START_DATE]
    ) || null),
    formEndDate: (maybeParseDate(
        data[submissionFields.FORM_END_DATE]
      ) || null),
    completedDate: (maybeParseDate(
        data[submissionFields.COMPLETED_DATE]
      ) || null)
  };
}

/**
 * Enum for ODK Aggregate form fields relevant to facilities
 * @enum {string}
 */
const facilityFields = {
  REGION: 'region',
  FACILITY: 'facility',
  TYPE: 'ftype'
};

/**
 * Parses the facility details from a form submission
 *
 * @param  {Object} data - The published form submission
 * @return {Facility}      [description]
 */
function parseFacility(data) {
  log.debug('Parse facility');

  return {
    name: data[facilityFields.FACILITY],
    region: data[facilityFields.REGION],
    type: data[facilityFields.TYPE] || null
  };
}

/**
 * Enum for ODK Aggregate form fields relevant to people
 * @enum {string}
 */
const personFields = {
  PERSON: 'person'
};

/**
 * Parses the person details from a form submission
 *
 * @param  {Object} data - The published form submission
 * @return {Person}
 */
function parsePerson(data) {
  log.debug('Parse person');

  return {
    name: data[personFields.PERSON]
  };
}

/**
 * Enum for ODK Aggregate form fields relevant to data storage
 * @enum {string}
 */
const updatesFields = {
  SUBMISSION_ID: 'instanceID',
  INSTANCE_ID: 'instanceID',
  SAMPLE_REPEAT: 'srepeat',
  ST_ID: 'stid',
  LAB_ID: 'labid',
  STATUS: 'condition'
};

/**
 * Transforms the submission data object into an array of objects. Each array
 * value contains one field and value pair.
 *
 * @param  {Object} data - The published form submission
 * @return {Array.<Update>}
 */
function parseUpdates(data) {
  log.debug('Parsing updates');

  var samples = data[updatesFields.SAMPLE_REPEAT];
  return BPromise.map(samples, function(item, index) {
    return {
      submissionId: data[updatesFields.SUBMISSION_ID],
      submissionNumber: index + 1,
      stId: item[updatesFields.ST_ID] || null,
      labId: item[updatesFields.LAB_ID] || null,
      sampleStatus: item[updatesFields.STATUS] || null
    };
  });
}

/**
 * A form submission generated by ODK Aggregate's simple JSON publisher.
 *
 * @typedef Published
 * @property {string} token - The publisher auth token
 * @property {string} content -
 * @property {formId} formId - The source ODK form identifier
 * @property {formVersion} formVersion -
 * @property {Array} data - The content or body of the form submission. This
 *                        array may include 1 or more separate form submissions.
 */

/**
 * The published data, transformed into Sample Tracking objects.
 *
 * @typedef {Object} PublishTransformed
 * @property {Sample} samples - The sample Ids
 * @property {Submission} submission - [description]
 * @property {Facility} facility - [description]
 * @property {Person} person - [description]
 * @property {Update} update - [description]
 */

/**
 * Enum for ODK Aggregate form-level fields
 * @enum {string}
 */
const formFields = {
  FORM_ID: 'formId'
};

/**
 * Reshapes data from the JSON generated by the ODK Aggregate publishers to fit
 * the local application's data models.
 *
 * @param  {Published} published   ODK Aggregate form submission as "simple JSON"
 * @return {Array.<PublishTransformed>}
 */
const parsePublished = function(published) {
  log.info('Parsing aggregate publish data', published);

  var formId = published[formFields.FORM_ID];
  return BPromise.map(published.data, function(submission) {
    return BPromise.props({
      samples: parseSamples(submission),
      submission: parseSubmission(formId, submission),
      facility: parseFacility(submission),
      person: parsePerson(submission),
      updates: parseUpdates(submission)
    });
  });
};

module.exports = parsePublished;
